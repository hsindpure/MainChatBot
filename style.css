define([
    'jquery',
    'qlik',
    './properties',
    'text!./template.html',
    'text!./style.css',
    'https://code.highcharts.com/highcharts.js' ,// Highcharts CDN
    'https://code.highcharts.com/highcharts-3d.js' // Highcharts 3D CDN
], function($, qlik, props, template, cssContent, Highcharts) { // Removed Highcharts3D from arguments
    'use strict';

    // Add CSS to document head
    $('<style>').html(cssContent).appendTo('head');

    // Apply Highcharts 3D - Moved inside the define callback
    require(['https://code.highcharts.com/highcharts-3d.js'], function(Highcharts3D) {
        if (Highcharts3D) {
            Highcharts3D(Highcharts);
            console.log('Highcharts 3D module loaded and applied.');
        } else {
            console.error('Highcharts 3D module failed to load.');
        }
    });

    return {
        template: template,
        definition: props,
        controller: ['$scope', '$element', '$timeout', function($scope, $element, $timeout) { // Inject $timeout
            const app = qlik.currApp();
            let MainData = [];
            let hypercubeData = {};
            let chatHistory = [];
            let currentUser = 'User';
            let selectedRole = 'Analyst';
            let isListening = false;
            let recognition;
            let chartInstances = {}; // Track chart instances for cleanup
            let currentChartType = null; // Track the current chart type
            let lastContainerId = null; // Track the last chart container ID

            // Chart-related keywords for detection
            const chartKeywords = ['chart', 'show chart', 'create chart', 'visualization', 'graph', 'plot', 'diagram', 'visual', 'trend', 'bar chart', 'line chart', 'pie chart', 'scatter plot', 'column chart', '3d chart', '3d graph', '3d plot'];

            // Initialize Speech Recognition
            if ('webkitSpeechRecognition' in window) {
                recognition = new webkitSpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';
            }

            // Fetch app data on initialization
            $scope.$watch('layout', function(newVal) {
                if (newVal) {
                    fetchAppData();
                    initializeChatbot();
                }
            });

            function fetchAppData() {
                // Get app info
                app.getAppLayout().then(function(layout) {
                    $scope.appName = layout["layout"].qTitle || 'QlikSense App';
                    $scope.$apply();
                });

                // Create hypercube to fetch all app data
                const hypercubeDef = {
                    qDimensions: [],
                    qMeasures: [],
                    qInitialDataFetch: [{
                        qTop: 0,
                        qLeft: 0,
                        qHeight: 1000,
                        qWidth: 50
                    }]
                };

                // Get all fields and create dimensions/measures
                app.getList('FieldList').then(function(reply) {
                    console.log("reply", reply.layout.qFieldList.qItems);
                    const fields = reply.layout.qFieldList.qItems;

                    fields.forEach(function(field, index) {
                        if (index < 20) {
                            if (field.qCardinal < 100) {
                                hypercubeDef.qDimensions.push({
                                    qDef: {
                                        qFieldDefs: [field.qName],
                                        qSortCriterias: [{
                                            qSortByState: 1,
                                            qSortByAscii: 1
                                        }]
                                    }
                                });
                            } else {
                                hypercubeDef.qMeasures.push({
                                    qDef: {
                                        qDef: `Sum([${field.qName}])`,
                                        qLabel: field.qName
                                    }
                                });
                            }
                        }
                    });

                    // Create hypercube object
                    app.createCube(hypercubeDef).then(function(model) {
                        model.getLayout().then(function(layout) {
                            console.log("data-layout", layout);
                            hypercubeData = {
                                dimensions: layout.qHyperCube.qDimensionInfo,
                                measures: layout.qHyperCube.qMeasureInfo,
                                data: layout.qHyperCube.qDataPages[0] ? layout.qHyperCube.qMatrix : []
                            };
                        });
                    });
                });
            }

            // Process object data
            const objects = $scope.$parent.layout.props.objects;
            console.log(objects);

            const elements = objects.split(',').map(item => item.trim());
            const myArrayObjects = [];
            elements.forEach(element => myArrayObjects.push(element));

            const fetchDataAndProcess = async (objectID) => {
                const jsonDataArray = [];

                try {
                    const model = await app.getObject(objectID);
                    const layout = model.layout;
                    console.log(model);

                    if (!layout.qHyperCube) {
                        return [];
                    }

                    const totalDimensions = layout.qHyperCube.qDimensionInfo.length;
                    const totalMeasures = layout.qHyperCube.qMeasureInfo.length;
                    const totalColumns = totalDimensions + totalMeasures;

                    if (totalColumns === 0) return [];

                    const totalRows = layout.qHyperCube.qSize.qcy;
                    const pageSize = 500;
                    const totalPages = Math.min(Math.ceil(totalRows / pageSize), 5);

                    const headers = layout.qHyperCube.qDimensionInfo
                        .map(d => d.qFallbackTitle)
                        .concat(layout.qHyperCube.qMeasureInfo.map(m => m.qFallbackTitle))
                        .filter(h => h !== undefined);

                    for (let currentPage = 0; currentPage < totalPages; currentPage++) {
                        const qTop = currentPage * pageSize;
                        const qHeight = Math.min(pageSize, totalRows - qTop);

                        if (qHeight <= 0) break;

                        const dataPages = await model.getHyperCubeData('/qHyperCubeDef', [{
                            qTop,
                            qLeft: 0,
                            qWidth: totalColumns,
                            qHeight
                        }]);

                        dataPages[0].qMatrix.forEach(data => {
                            const jsonData = {};
                            headers.forEach((header, index) => {
                                jsonData[header] = data[index]?.qText || null;
                            });
                            jsonDataArray.push(jsonData);
                        });
                    }
                } catch (error) {
                    console.warn(`Error fetching data for object ${objectID}:`, error);
                    return [];
                }
                return jsonDataArray;
            };

            let sursa = [];
            let allObjData = [];
            myArrayObjects.forEach(function(objectID) {
                fetchDataAndProcess(objectID).then(jsonDataArray => {
                    console.log(jsonDataArray);
                    allObjData.push(jsonDataArray);
                    sursa = JSON.stringify(allObjData);
                    console.log("all Objects Data in string", sursa);
                }).catch(error => {
                    console.error("Error fetching data:", error);
                });
            });

            function initializeChatbot() {
                const $chatbot = $element.find('.chatbot-container');
                const $toggle = $element.find('.chatbot-toggle');
                const $close = $element.find('.chatbot-close');
                const $sendBtn = $element.find('.send-button');
                const $input = $element.find('.chat-input');
                const $voiceBtn = $element.find('.voice-button');
                const $roleSelect = $element.find('.role-select');
                const $downloadBtn = $element.find('.download-history');

                // Toggle chatbot
                $toggle.on('click', function() {
                    $chatbot.addClass('active');
                    $input.focus();
                });

                // Close chatbot
                $close.on('click', function() {
                    $chatbot.removeClass('active');
                });

                // Send message
                $sendBtn.on('click', sendMessage);
                $input.on('keypress', function(e) {
                    if (e.which === 13) {
                        sendMessage();
                    }
                });

                // Voice input
                $voiceBtn.on('click', toggleVoiceInput);

                // Role selection
                $roleSelect.on('change', function() {
                    selectedRole = $(this).val();
                    addMessage('system', `Role changed to: ${selectedRole}`);
                });

                // Download history
                $downloadBtn.on('click', downloadChatHistory);

                // Initialize with welcome message
                addMessage('bot', `Hello! I'm your AI assistant for ${$scope.appName || 'this QlikSense app'}. I can help you analyze your data and create interactive visualizations. Try asking me to "create a chart" or "show me a graph"!`);
            }

            function sendMessage() {
                const $input = $element.find('.chat-input');
                const message = $input.val().trim();

                if (!message) return;

                // Add user message
                addMessage('user', message);
                $input.val('');

                // Show typing indicator
                showTypingIndicator();

                // Send to AI API
                processWithAI(message);
            }

            function detectChartRequest(query) {
                const lowerQuery = query.toLowerCase();
                return chartKeywords.some(keyword => lowerQuery.includes(keyword));
            }

            // Modify processWithAI to update the chart on drilldown
            async function processWithAI(query) {
                MainData.push(hypercubeData);

                const decryptedKey = "key";

                const baseUrl = "url";

                let model;
                let context = '4o';
                if (context === '8k') {
                    model = "mmc-tech-gpt-35-turbo-smart-latest";
                } else if (context === '16k') {
                    model = 'mmc-tech-gpt-35-turbo-16k-0613';
                } else if (context === '4o') {
                    model = "mmc-tech-gpt-4o-mini-128k-2024-07-18";
                }

                const endpoint = `deployments/${model}/chat/completions`;
                const url = `${baseUrl}${endpoint}`;
                const temp = 0.2; // Ranges 0-2

                let Data = JSON.stringify(hypercubeData);
                let prompt = `You are ${selectedRole}, You are a highly skilled health insurance business analyst. Utilize the JSON data provided below after 'data:', which includes information claims data. Your primary objective is to analyze this data and answer the query asked after the data segment in query:<> format in this message. Always emphasize clarity and correctness in your answers to provide the best possible insights.  response should be pointwise in use html elements`;

                switch (selectedRole) {
                    case 'Analyst':
                        prompt += ` As a skilled analyst, focus on data trends, patterns, and statistical insights.response should be pointwise in use html elements`;
                        break;
                    case 'HR':
                        prompt += ` As an HR professional, emphasize employee-related insights, performance metrics, and organizational trends.response should be pointwise in use html elements`;
                        break;
                    case 'Manager':
                        prompt += ` As a manager, provide strategic insights, performance summaries, and actionable recommendations. response should be pointwise in use html elements`;
                        break;
                    case 'Executive':
                        prompt += ` As an executive, focus on high-level strategic insights, KPIs, and business impact. response should be pointwise in use html elements`;
                        break;
                }
                const isChartRequest = detectChartRequest(query);

                if (isChartRequest) {
                    prompt = `You are ${selectedRole}, a data visualization expert. Based on the QlikSense data provided, create a Highcharts configuration for the user's request.

                    IMPORTANT: Respond with a JSON object containing:
                    1. "message": A brief explanation of the chart.
                    2. "chartConfig": A complete Highcharts configuration object (in JSON format).
                    3. "chartType": The type of chart (bar, line, pie, scatter, column, etc.).  If the chart is 3D, specify that in the chartType.

                    The chartConfig should include:
                    - chart: with type (e.g., 'bar', 'line', 'pie', 'column', 'scatter', 'column3d', 'pie3d') and optionally options3d for 3D charts.
                    - title: with text
                    - xAxis: with categories or title
                    - yAxis: with title
                    - series: with type, data, and name

                    Use the actual data from the provided dataset. Make the chart interactive with hover effects and click handlers. Ensure the configuration is valid JSON.

                    Example format (Column Chart):
                    {
                        "message": "Here's a column chart showing...",
                        "chartConfig": {
                            "chart": {
                                "type": "column"
                            },
                            "title": {
                                "text": "My Chart"
                            },
                            "xAxis": {
                                "categories": ["Label1", "Label2"]
                            },
                            "yAxis": {
                                "title": {
                                    "text": "Value"
                                }
                            },
                            "series": [{
                                "name": "Dataset Label",
                                "data": [10, 20]
                            }]
                        },
                        "chartType": "column"
                    }

                    Example format (3D Column Chart):
                    {
                        "message": "Here's a 3D column chart showing...",
                        "chartConfig": {
                            "chart": {
                                "type": "column3d",
                                "options3d": {
                                    "enabled": true,
                                    "alpha": 15,
                                    "beta": 15,
                                    "depth": 50
                                }
                            },
                            "title": {
                                "text": "My 3D Chart"
                            },
                            "xAxis": {
                                "categories": ["Label1", "Label2"]
                            },
                            "yAxis": {
                                "title": {
                                    "text": "Value"
                                }
                            },
                            "series": [{
                                "name": "Dataset Label",
                                "data": [10, 20]
                            }]
                        },
                        "chartType": "column3d"
                    }
                    `;
                }

                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${decryptedKey}`
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: [{
                                role: "user",
                                content: `${prompt} data:${sursa} query:${query}`
                            }],
                            temperature: temp,
                            max_tokens: 2000,
                            response_format: isChartRequest ? {
                                type: "json_object"
                            } : undefined
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    const aiResponse = data.choices[0].message.content;

                    hideTypingIndicator();

                    if (isChartRequest) {
                        try {
                            const chartResponse = JSON.parse(aiResponse);
                            console.log('AI Response:', chartResponse); // Debugging
                            // Update the existing chart
                            if (lastContainerId) {
                                console.log('lastContainerId:', lastContainerId); // Debugging
                                generateChart(lastContainerId, chartResponse.chartConfig, chartResponse.chartType);
                            } else {
                                addMessage('bot', chartResponse.message || 'Here\'s your chart:', chartResponse.chartConfig, chartResponse.chartType);
                            }
                        } catch (parseError) {
                            console.error('Error parsing chart response:', parseError);
                            addMessage('bot', 'I encountered an error generating the chart. Here\'s the analysis instead: ' + aiResponse);
                        }
                    } else {
                        addMessage('bot', aiResponse);
                    }

                } catch (error) {
                    console.error('Error calling AI API:', error);
                    hideTypingIndicator();
                    addMessage('bot', 'I apologize, but I encountered an error processing your request. Please try again.');
                }
            }

            function addMessage(sender, message, chartConfig = null, chartType = null) {
                const $messages = $element.find('.chat-messages');
                const timestamp = new Date().toLocaleTimeString();
                const messageId = 'msg_' + Date.now();

                let messageClass = sender === 'user' ? 'user-message' : 'bot-message';
                let icon = sender === 'user' ? '\ud83d\udc64' : '\ud83e\udd16';
                let name = sender === 'user' ? currentUser : 'AI Assistant';

                if (sender === 'system') {
                    messageClass = 'system-message';
                    icon = '\u2699\ufe0f';
                    name = 'System';
                }

                let messageHtml = `
                    <div class="message ${messageClass}" id="${messageId}">
                        <div class="message-content">
                            <div class="message-header">
                                <span class="${sender}-icon">${icon}</span>
                                <span class="${sender}-name">${name}</span>
                                <span class="timestamp">${timestamp}</span>
                            </div>
                            <div class="message-text">${message}</div>
                            ${chartConfig ? `<div class="chart-container" id="chart_${messageId}"></div>` : ''}
                            <div class="hear-responce ${sender}">
                                <button class="speak-button" onclick="speakText('${message.replace(/'/g, "\\'")}')">
                                    <i class="fas fa-volume-up"></i>
                                </button>
                                <button class="copy-button" onclick="copyToClipboard('${message.replace(/'/g, "\\'")}')">
                                    <i class="fas fa-copy"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `;

                $messages.append(messageHtml);
                $messages.scrollTop($messages[0].scrollHeight);

                // Generate chart if chartConfig is provided
                if (chartConfig) {
                    lastContainerId = `chart_${messageId}`; // Store the container ID
                    // Using $timeout to ensure DOM is ready
                    $timeout(() => {
                        generateChart(lastContainerId, chartConfig, chartType);
                    }, 300);
                }

                // Add to chat history
                chatHistory.push({
                    sender: sender,
                    message: message,
                    timestamp: timestamp,
                    chartConfig: chartConfig
                });
            }

            function generateChart(containerId, chartConfig, chartType) {
                const container = document.getElementById(containerId);
                if (!container) {
                    console.error('Chart container not found:', containerId);
                    return;
                }

                // Clear previous content
                container.innerHTML = '';

                try {
                    // Initialize Highcharts
                    Highcharts.chart(containerId, chartConfig);
                } catch (error) {
                    console.error('Highcharts Error:', error);
                }
            }

            function showTypingIndicator() {
                const $messages = $element.find('.chat-messages');
                const typingHtml = `
                    <div class="message typing-indicator">
                        <div class="message-content">
                            <div class="typing-animation">
                                <span></span>
                                <span></span>
                                <span></span>
                            </div>
                        </div>
                    </div>
                `;
                $messages.append(typingHtml);
                $messages.scrollTop($messages[0].scrollHeight);
            }

            function hideTypingIndicator() {
                $element.find('.typing-indicator').remove();
            }

            function toggleVoiceInput() {
                if (!recognition) {
                    alert('Voice recognition is not supported in your browser.');
                    return;
                }

                const $voiceBtn = $element.find('.voice-button');

                if (isListening) {
                    recognition.stop();
                    isListening = false;
                    $voiceBtn.removeClass('listening');
                } else {
                    recognition.start();
                    isListening = true;
                    $voiceBtn.addClass('listening');
                }

                recognition.onresult = function(event) {
                    const transcript = event.results[0][0].transcript;
                    $element.find('.chat-input').val(transcript);
                    isListening = false;
                    $voiceBtn.removeClass('listening');
                };

                recognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    isListening = false;
                    $voiceBtn.removeClass('listening');
                };
            }

            function downloadChatHistory() {
                const dataStr = JSON.stringify(chatHistory, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);

                const exportFileDefaultName = `chat_history_${new Date().toISOString().split('T')[0]}.json`;

                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
            }

            // Global functions for message controls
            window.speakText = function(text) {
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 0.8;
                    utterance.pitch = 1;
                    speechSynthesis.speak(utterance);
                } else {
                    alert('Text-to-speech is not supported in your browser.');
                }
            };

            window.copyToClipboard = function(text) {
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(text).then(() => {
                        // Show temporary feedback
                        const feedback = document.createElement('div');
                        feedback.textContent = 'Copied!';
                        feedback.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #4CAF50; color: white; padding: 8px 16px; border-radius: 4px; z-index: 10001;';
                        document.body.appendChild(feedback);
                        setTimeout(() => document.body.removeChild(feedback), 2000);
                    });
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                }
            };

            // Cleanup function
            $scope.$on('$destroy', function() {
                // Destroy all chart instances
                Object.values(chartInstances).forEach(chart => {
                    // Highcharts charts don't need explicit disposal
                });
                chartInstances = {};
            });
        }]
    };
});
