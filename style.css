define([
    'jquery',
    'qlik',
    './properties',
    'text!./template.html',
    'text!./style.css',
    'https://cdn.amcharts.com/lib/4/core.js',
    'https://cdn.amcharts.com/lib/4/charts.js',
    'https://cdn.amcharts.com/lib/4/themes/animated.js'
], function($, qlik, props, template, cssContent, am4core, am4charts, am4themes_animated) {
    'use strict';

    // Add CSS to document head
    $('<style>').html(cssContent).appendTo('head');

    // Apply amCharts theme
    am4core.useTheme(am4themes_animated.default);

    return {
        template: template,
        definition: props,
        controller: ['$scope', '$element', '$timeout', function($scope, $element, $timeout) {
            const app = qlik.currApp();
            let MainData = [];
            let hypercubeData = {};
            let chatHistory = [];
            let currentUser = 'User';
            let selectedRole = 'Analyst';
            let isListening = false;
            let recognition;
            let chartInstances = {};
            let currentChartType = null;
            let lastContainerId = null;

            const chartKeywords = ['chart', 'show chart', 'create chart', 'visualization', 'graph', 'plot', 'diagram', 'visual', 'trend', 'bar chart', 'line chart', 'pie chart', 'scatter plot', 'column chart'];

            if ('webkitSpeechRecognition' in window) {
                recognition = new webkitSpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';
            }

            $scope.$watch('layout', function(newVal) {
                if (newVal) {
                    fetchAppData();
                    initializeChatbot();
                }
            });

            function fetchAppData() {
                app.getAppLayout().then(function(layout) {
                    $scope.appName = layout["layout"].qTitle || 'QlikSense App';
                    $scope.$apply();
                });

                const hypercubeDef = {
                    qDimensions: [],
                    qMeasures: [],
                    qInitialDataFetch: [{
                        qTop: 0,
                        qLeft: 0,
                        qHeight: 1000,
                        qWidth: 50
                    }]
                };

                app.getList('FieldList').then(function(reply) {
                    console.log("reply", reply.layout.qFieldList.qItems);
                    const fields = reply.layout.qFieldList.qItems;

                    fields.forEach(function(field, index) {
                        if (index < 20) {
                            if (field.qCardinal < 100) {
                                hypercubeDef.qDimensions.push({
                                    qDef: {
                                        qFieldDefs: [field.qName],
                                        qSortCriterias: [{
                                            qSortByState: 1,
                                            qSortByAscii: 1
                                        }]
                                    }
                                });
                            } else {
                                hypercubeDef.qMeasures.push({
                                    qDef: {
                                        qDef: `Sum([${field.qName}])`,
                                        qLabel: field.qName
                                    }
                                });
                            }
                        }
                    });

                    app.createCube(hypercubeDef).then(function(model) {
                        model.getLayout().then(function(layout) {
                            console.log("data-layout", layout);
                            hypercubeData = {
                                dimensions: layout.qHyperCube.qDimensionInfo,
                                measures: layout.qHyperCube.qMeasureInfo,
                                data: layout.qHyperCube.qDataPages[0] ? layout.qHyperCube.qMatrix : []
                            };
                        });
                    });
                });
            }

            const objects = $scope.$parent.layout.props.objects;
            console.log(objects);

            const elements = objects.split(',').map(item => item.trim());
            const myArrayObjects = [];
            elements.forEach(element => myArrayObjects.push(element));

            const fetchDataAndProcess = async (objectID) => {
                const jsonDataArray = [];

                try {
                    const model = await app.getObject(objectID);
                    const layout = model.layout;
                    console.log(model);

                    if (!layout.qHyperCube) {
                        return [];
                    }

                    const totalDimensions = layout.qHyperCube.qDimensionInfo.length;
                    const totalMeasures = layout.qHyperCube.qMeasureInfo.length;
                    const totalColumns = totalDimensions + totalMeasures;

                    if (totalColumns === 0) return [];

                    const totalRows = layout.qHyperCube.qSize.qcy;
                    const pageSize = 500;
                    const totalPages = Math.min(Math.ceil(totalRows / pageSize), 5);

                    const headers = layout.qHyperCube.qDimensionInfo
                        .map(d => d.qFallbackTitle)
                        .concat(layout.qHyperCube.qMeasureInfo.map(m => m.qFallbackTitle))
                        .filter(h => h !== undefined);

                    for (let currentPage = 0; currentPage < totalPages; currentPage++) {
                        const qTop = currentPage * pageSize;
                        const qHeight = Math.min(pageSize, totalRows - qTop);

                        if (qHeight <= 0) break;

                        const dataPages = await model.getHyperCubeData('/qHyperCubeDef', [{
                            qTop,
                            qLeft: 0,
                            qWidth: totalColumns,
                            qHeight
                        }]);

                        dataPages[0].qMatrix.forEach(data => {
                            const jsonData = {};
                            headers.forEach((header, index) => {
                                jsonData[header] = data[index]?.qText || null;
                            });
                            jsonDataArray.push(jsonData);
                        });
                    }
                } catch (error) {
                    console.warn(`Error fetching data for object ${objectID}:`, error);
                    return [];
                }
                return jsonDataArray;
            };

            let sursa = [];
            let allObjData = [];
            myArrayObjects.forEach(function(objectID) {
                fetchDataAndProcess(objectID).then(jsonDataArray => {
                    console.log(jsonDataArray);
                    allObjData.push(jsonDataArray);
                    sursa = JSON.stringify(allObjData);
                    console.log("all Objects Data in string", sursa);
                }).catch(error => {
                    console.error("Error fetching data:", error);
                });
            });

            function initializeChatbot() {
                const $chatbot = $element.find('.chatbot-container');
                const $toggle = $element.find('.chatbot-toggle');
                const $close = $element.find('.chatbot-close');
                const $sendBtn = $element.find('.send-button');
                const $input = $element.find('.chat-input');
                const $voiceBtn = $element.find('.voice-button');
                const $roleSelect = $element.find('.role-select');
                const $downloadBtn = $element.find('.download-history');

                $toggle.on('click', function() {
                    $chatbot.addClass('active');
                    $input.focus();
                });

                $close.on('click', function() {
                    $chatbot.removeClass('active');
                });

                $sendBtn.on('click', sendMessage);
                $input.on('keypress', function(e) {
                    if (e.which === 13) {
                        sendMessage();
                    }
                });

                $voiceBtn.on('click', toggleVoiceInput);

                $roleSelect.on('change', function() {
                    selectedRole = $(this).val();
                    addMessage('system', `Role changed to: ${selectedRole}`);
                });

                $downloadBtn.on('click', downloadChatHistory);

                addMessage('bot', `Hello! I'm your AI assistant for ${$scope.appName || 'this QlikSense app'}. I can help you analyze your data and create interactive visualizations. Try asking me to "create a chart" or "show me a graph"!`);
            }

            function sendMessage() {
                const $input = $element.find('.chat-input');
                const message = $input.val().trim();

                if (!message) return;

                addMessage('user', message);
                $input.val('');

                showTypingIndicator();

                processWithAI(message);
            }

            function detectChartRequest(query) {
                const lowerQuery = query.toLowerCase();
                return chartKeywords.some(keyword => lowerQuery.includes(keyword));
            }

            async function processWithAI(query) {
                MainData.push(hypercubeData);

                const decryptedKey = "key";

                const baseUrl = "url";

                let model;
                let context = '4o';
                if (context === '8k') {
                    model = "mmc-tech-gpt-35-turbo-smart-latest";
                } else if (context === '16k') {
                    model = 'mmc-tech-gpt-35-turbo-16k-0613';
                } else if (context === '4o') {
                    model = "mmc-tech-gpt-4o-mini-128k-2024-07-18";
                }

                const endpoint = `deployments/${model}/chat/completions`;
                const url = `${baseUrl}${endpoint}`;
                const temp = 0.2;

                let Data = JSON.stringify(hypercubeData);
                let prompt = `You are ${selectedRole}, You are a highly skilled health insurance business analyst. Utilize the JSON data provided below after 'data:', which includes information claims data. Your primary objective is to analyze this data and answer the query asked after the data segment in query:<> format in this message. Always emphasize clarity and correctness in your answers to provide the best possible insights.  response should be pointwise in use html elements`;

                switch (selectedRole) {
                    case 'Analyst':
                        prompt += ` As a skilled analyst, focus on data trends, patterns, and statistical insights.response should be pointwise in use html elements`;
                        break;
                    case 'HR':
                        prompt += ` As an HR professional, emphasize employee-related insights, performance metrics, and organizational trends.response should be pointwise in use html elements`;
                        break;
                    case 'Manager':
                        prompt += ` As a manager, provide strategic insights, performance summaries, and actionable recommendations. response should be pointwise in use html elements`;
                        break;
                    case 'Executive':
                        prompt += ` As an executive, focus on high-level strategic insights, KPIs, and business impact. response should be pointwise in use html elements`;
                        break;
                }
                const isChartRequest = detectChartRequest(query);

                if (isChartRequest) {
                    prompt = `You are ${selectedRole}, a data visualization expert using amCharts. Based on the QlikSense data provided, create an amCharts configuration object for the user's request.

                    IMPORTANT: Respond with a JSON object containing:
                    1. "message": A brief explanation of the chart.
                    2. "chartConfig": A complete amCharts configuration object (in JSON format).
                    3. "chartType": The type of chart (bar, line, pie, scatter, column, etc.).

                    The chartConfig should include:
                    - "type": The chart type (e.g., "XYChart", "PieChart").
                    - "data": An array of data objects.
                    - "xAxes" or "yAxes": Axis configurations.
                    - "series": Series configurations.

                    Example format (Column Chart):
                    {
                        "message": "Here's a column chart showing...",
                        "chartConfig": {
                            "type": "XYChart",
                            "data": [
                                {"category": "Label1", "value": 10},
                                {"category": "Label2", "value": 20}
                            ],
                            "xAxes": [{
                                "type": "CategoryAxis",
                                "dataFields": { "category": "category" }
                            }],
                            "yAxes": [{
                                "type": "ValueAxis"
                            }],
                            "series": [{
                                "type": "ColumnSeries",
                                "dataFields": {
                                    "valueY": "value",
                                    "categoryX": "category"
                                }
                            }]
                        },
                        "chartType": "column"
                    }

                    Do NOT include any amCharts code outside of the chartConfig object.
                    `;
                }

                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${decryptedKey}`
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: [{
                                role: "user",
                                content: `${prompt} data:${sursa} query:${query}`
                            }],
                            temperature: temp,
                            max_tokens: 2000,
                            response_format: isChartRequest ? {
                                type: "json_object"
                            } : undefined
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    const aiResponse = data.choices[0].message.content;

                    hideTypingIndicator();

                    if (isChartRequest) {
                        try {
                            const chartResponse = JSON.parse(aiResponse);
                            console.log('AI Response:', chartResponse);
                            if (lastContainerId) {
                                console.log('lastContainerId:', lastContainerId);
                                generateChart(lastContainerId, chartResponse.chartConfig, chartResponse.chartType);
                            } else {
                                addMessage('bot', chartResponse.message || 'Here\'s your chart:', chartResponse.chartConfig, chartResponse.chartType);
                            }
                        } catch (parseError) {
                            console.error('Error parsing chart response:', parseError);
                            addMessage('bot', 'I encountered an error generating the chart. Here\'s the analysis instead: ' + aiResponse);
                        }
                    } else {
                        addMessage('bot', aiResponse);
                    }

                } catch (error) {
                    console.error('Error calling AI API:', error);
                    hideTypingIndicator();
                    addMessage('bot', 'I apologize, but I encountered an error processing your request. Please try again.');
                }
            }

            function addMessage(sender, message, chartConfig = null, chartType = null) {
                const $messages = $element.find('.chat-messages');
                const timestamp = new Date().toLocaleTimeString();
                const messageId = 'msg_' + Date.now();

                let messageClass = sender === 'user' ? 'user-message' : 'bot-message';
                let icon = sender === 'user' ? '\ud83d\udc64' : '\ud83e\udd16';
                let name = sender === 'user' ? currentUser : 'AI Assistant';

                if (sender === 'system') {
                    messageClass = 'system-message';
                    icon = '\u2699\ufe0f';
                    name = 'System';
                }

                let messageHtml = `
                    <div class="message ${messageClass}" id="${messageId}">
                        <div class="message-content">
                            <div class="message-header">
                                <span class="${sender}-icon">${icon}</span>
                                <span class="${sender}-name">${name}</span>
                                <span class="timestamp">${timestamp}</span>
                            </div>
                            <div class="message-text">${message}</div>
                            ${chartConfig ? `<div class="chart-container" id="chart_${messageId}"></div>` : ''}
                            <div class="hear-responce ${sender}">
                                <button class="speak-button" onclick="speakText('${message.replace(/'/g, "\\'")}')">
                                    <i class="fas fa-volume-up"></i>
                                </button>
                                <button class="copy-button" onclick="copyToClipboard('${message.replace(/'/g, "\\'")}')">
                                    <i class="fas fa-copy"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `;

                $messages.append(messageHtml);
                $messages.scrollTop($messages[0].scrollHeight);

                if (chartConfig) {
                    lastContainerId = `chart_${messageId}`;
                    $timeout(() => {
                        generateChart(lastContainerId, chartConfig, chartType);
                    }, 300);
                }

                chatHistory.push({
                    sender: sender,
                    message: message,
                    timestamp: timestamp,
                    chartConfig: chartConfig
                });
            }

            function generateChart(containerId, chartConfig, chartType) {
                const container = document.getElementById(containerId);
                if (!container) {
                    console.error('Chart container not found:', containerId);
                    return;
                }

                container.innerHTML = ''; // Clear previous content

                try {
                    // Create chart instance
                    let chart = am4core.create(containerId, am4core[chartConfig.type]);

                    // Set data
                    chart.data = chartConfig.data;

                    // Copy properties from chartConfig to chart
                    for (let key in chartConfig) {
                        if (key !== 'type' && key !== 'data') {
                            chart[key] = chartConfig[key];
                        }
                    }

                    // Manually create axes and series based on chart type
                    if (chartConfig.type === "XYChart") {
                        // Create axes
                        let categoryAxis = chart.xAxes.push(new am4charts.CategoryAxis());
                        categoryAxis.dataFields.category = chartConfig.xAxes[0].dataFields.category;

                        let valueAxis = chart.yAxes.push(new am4charts.ValueAxis());

                        // Create series
                        let series = chart.series.push(new am4charts[chartConfig.series[0].type]());
                        series.dataFields.valueY = chartConfig.series[0].dataFields.valueY;
                        series.dataFields.categoryX = chartConfig.series[0].dataFields.categoryX;
                    } else if (chartConfig.type === "PieChart") {
                        // Create series
                        let series = chart.series.push(new am4charts.PieSeries());
                        series.dataFields.value = chartConfig.series[0].dataFields.value;
                        series.dataFields.category = chartConfig.series[0].dataFields.category;
                    }

                    // Store chart instance for later disposal
                    chartInstances[containerId] = chart;

                } catch (error) {
                    console.error('amCharts Error:', error);
                }
            }

            function showTypingIndicator() {
                const $messages = $element.find('.chat-messages');
                const typingHtml = `
                    <div class="message typing-indicator">
                        <div class="message-content">
                            <div class="typing-animation">
                                <span></span>
                                <span></span>
                                <span></span>
                            </div>
                        </div>
                    </div>
                `;
                $messages.append(typingHtml);
                $messages.scrollTop($messages[0].scrollHeight);
            }

            function hideTypingIndicator() {
                $element.find('.typing-indicator').remove();
            }

            function toggleVoiceInput() {
                if (!recognition) {
                    alert('Voice recognition is not supported in your browser.');
                    return;
                }

                const $voiceBtn = $element.find('.voice-button');

                if (isListening) {
                    recognition.stop();
                    isListening = false;
                    $voiceBtn.removeClass('listening');
                } else {
                    recognition.start();
                    isListening = true;
                    $voiceBtn.addClass('listening');
                }

                recognition.onresult = function(event) {
                    const transcript = event.results[0][0].transcript;
                    $element.find('.chat-input').val(transcript);
                    isListening = false;
                    $voiceBtn.removeClass('listening');
                };

                recognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    isListening = false;
                    $voiceBtn.removeClass('listening');
                };
            }

            function downloadChatHistory() {
                const dataStr = JSON.stringify(chatHistory, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);

                const exportFileDefaultName = `chat_history_${new Date().toISOString().split('T')[0]}.json`;

                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
            }

            $scope.$on('$destroy', function() {
                Object.values(chartInstances).forEach(chart => {
                    if (chart) {
                        chart.dispose(); // Dispose of amCharts chart
                    }
                });
                chartInstances = {};
            });
        }]
    };
});
