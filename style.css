define([
    'jquery',
    'qlik',
    './properties',
    'text!./template.html',
    'text!./style.css',
    'https://d3js.org/d3.v7.min.js', // D3.js CDN
    'https://unpkg.com/d3-3d@1' // D3 3D CDN (or host locally)
], function($, qlik, props, template, cssContent, d3, d33d) {
    'use strict';

    // Add CSS to document head
    $('<style>').html(cssContent).appendTo('head');

    return {
        template: template,
        definition: props,
        controller: ['$scope', '$element', '$timeout', function($scope, $element, $timeout) {
            const app = qlik.currApp();
            let MainData = [];
            let hypercubeData = {};
            let chatHistory = [];
            let currentUser = 'User';
            let selectedRole = 'Analyst';
            let isListening = false;
            let recognition;
            let chartInstances = {};
            let currentChartType = null;
            let lastContainerId = null;

            const chartKeywords = ['chart', 'show chart', 'create chart', 'visualization', 'graph', 'plot', 'diagram', 'visual', 'trend', 'bar chart', 'line chart', 'pie chart', 'scatter plot', 'column chart', '3d chart', '3d graph', '3d plot'];

            if ('webkitSpeechRecognition' in window) {
                recognition = new webkitSpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';
            }

            $scope.$watch('layout', function(newVal) {
                if (newVal) {
                    fetchAppData();
                    initializeChatbot();
                }
            });

            function fetchAppData() {
                app.getAppLayout().then(function(layout) {
                    $scope.appName = layout["layout"].qTitle || 'QlikSense App';
                    $scope.$apply();
                });

                const hypercubeDef = {
                    qDimensions: [],
                    qMeasures: [],
                    qInitialDataFetch: [{
                        qTop: 0,
                        qLeft: 0,
                        qHeight: 1000,
                        qWidth: 50
                    }]
                };

                app.getList('FieldList').then(function(reply) {
                    console.log("reply", reply.layout.qFieldList.qItems);
                    const fields = reply.layout.qFieldList.qItems;

                    fields.forEach(function(field, index) {
                        if (index < 20) {
                            if (field.qCardinal < 100) {
                                hypercubeDef.qDimensions.push({
                                    qDef: {
                                        qFieldDefs: [field.qName],
                                        qSortCriterias: [{
                                            qSortByState: 1,
                                            qSortByAscii: 1
                                        }]
                                    }
                                });
                            } else {
                                hypercubeDef.qMeasures.push({
                                    qDef: {
                                        qDef: `Sum([${field.qName}])`,
                                        qLabel: field.qName
                                    }
                                });
                            }
                        }
                    });

                    app.createCube(hypercubeDef).then(function(model) {
                        model.getLayout().then(function(layout) {
                            console.log("data-layout", layout);
                            hypercubeData = {
                                dimensions: layout.qHyperCube.qDimensionInfo,
                                measures: layout.qHyperCube.qMeasureInfo,
                                data: layout.qHyperCube.qDataPages[0] ? layout.qHyperCube.qDataPages[0].qMatrix : []
                            };
                        });
                    });
                });
            }

            const objects = $scope.$parent.layout.props.objects;
            console.log(objects);

            const elements = objects.split(',').map(item => item.trim());
            const myArrayObjects = [];
            elements.forEach(element => myArrayObjects.push(element));

            const fetchDataAndProcess = async (objectID) => {
                const jsonDataArray = [];

                try {
                    const model = await app.getObject(objectID);
                    const layout = model.layout;
                    console.log(model);

                    if (!layout.qHyperCube) {
                        return [];
                    }

                    const totalDimensions = layout.qHyperCube.qDimensionInfo.length;
                    const totalMeasures = layout.qHyperCube.qMeasureInfo.length;
                    const totalColumns = totalDimensions + totalMeasures;

                    if (totalColumns === 0) return [];

                    const totalRows = layout.qHyperCube.qSize.qcy;
                    const pageSize = 500;
                    const totalPages = Math.min(Math.ceil(totalRows / pageSize), 5);

                    const headers = layout.qHyperCube.qDimensionInfo
                        .map(d => d.qFallbackTitle)
                        .concat(layout.qHyperCube.qMeasureInfo.map(m => m.qFallbackTitle))
                        .filter(h => h !== undefined);

                    for (let currentPage = 0; currentPage < totalPages; currentPage++) {
                        const qTop = currentPage * pageSize;
                        const qHeight = Math.min(pageSize, totalRows - qTop);

                        if (qHeight <= 0) break;

                        const dataPages = await model.getHyperCubeData('/qHyperCubeDef', [{
                            qTop,
                            qLeft: 0,
                            qWidth: totalColumns,
                            qHeight
                        }]);

                        dataPages[0].qMatrix.forEach(data => {
                            const jsonData = {};
                            headers.forEach((header, index) => {
                                jsonData[header] = data[index]?.qText || null;
                            });
                            jsonDataArray.push(jsonData);
                        });
                    }
                } catch (error) {
                    console.warn(`Error fetching data for object ${objectID}:`, error);
                    return [];
                }
                return jsonDataArray;
            };

            let sursa = [];
            let allObjData = [];
            myArrayObjects.forEach(function(objectID) {
                fetchDataAndProcess(objectID).then(jsonDataArray => {
                    console.log(jsonDataArray);
                    allObjData.push(jsonDataArray);
                    sursa = JSON.stringify(allObjData);
                    console.log("all Objects Data in string", sursa);
                }).catch(error => {
                    console.error("Error fetching data:", error);
                });
            });

            function initializeChatbot() {
                const $chatbot = $element.find('.chatbot-container');
                const $toggle = $element.find('.chatbot-toggle');
                const $close = $element.find('.chatbot-close');
                const $sendBtn = $element.find('.send-button');
                const $input = $element.find('.chat-input');
                const $voiceBtn = $element.find('.voice-button');
                const $roleSelect = $element.find('.role-select');
                const $downloadBtn = $element.find('.download-history');

                $toggle.on('click', function() {
                    $chatbot.addClass('active');
                    $input.focus();
                });

                $close.on('click', function() {
                    $chatbot.removeClass('active');
                });

                $sendBtn.on('click', sendMessage);
                $input.on('keypress', function(e) {
                    if (e.which === 13) {
                        sendMessage();
                    }
                });

                $voiceBtn.on('click', toggleVoiceInput);

                $roleSelect.on('change', function() {
                    selectedRole = $(this).val();
                    addMessage('system', `Role changed to: ${selectedRole}`);
                });

                $downloadBtn.on('click', downloadChatHistory);

                addMessage('bot', `Hello! I'm your AI assistant for ${$scope.appName || 'this QlikSense app'}. I can help you analyze your data and create interactive visualizations. Try asking me to "create a chart" or "show me a graph"!`);
            }

            function sendMessage() {
                const $input = $element.find('.chat-input');
                const message = $input.val().trim();

                if (!message) return;

                addMessage('user', message);
                $input.val('');

                showTypingIndicator();

                processWithAI(message);
            }

            function detectChartRequest(query) {
                const lowerQuery = query.toLowerCase();
                return chartKeywords.some(keyword => lowerQuery.includes(keyword));
            }

            async function processWithAI(query) {
                MainData.push(hypercubeData);

                const decryptedKey = "key";

                const baseUrl = "url";

                let model;
                let context = '4o';
                if (context === '8k') {
                    model = "mmc-tech-gpt-35-turbo-smart-latest";
                } else if (context === '16k') {
                    model = 'mmc-tech-gpt-35-turbo-16k-0613';
                } else if (context === '4o') {
                    model = "mmc-tech-gpt-4o-mini-128k-2024-07-18";
                }

                const endpoint = `deployments/${model}/chat/completions`;
                const url = `${baseUrl}${endpoint}`;
                const temp = 0.2;

                let Data = JSON.stringify(hypercubeData);
                let prompt = `You are ${selectedRole}, You are a highly skilled health insurance business analyst. Utilize the JSON data provided below after 'data:', which includes information claims data. Your primary objective is to analyze this data and answer the query asked after the data segment in query:<> format in this message. Always emphasize clarity and correctness in your answers to provide the best possible insights.  response should be pointwise in use html elements`;

                switch (selectedRole) {
                    case 'Analyst':
                        prompt += ` As a skilled analyst, focus on data trends, patterns, and statistical insights.response should be pointwise in use html elements`;
                        break;
                    case 'HR':
                        prompt += ` As an HR professional, emphasize employee-related insights, performance metrics, and organizational trends.response should be pointwise in use html elements`;
                        break;
                    case 'Manager':
                        prompt += ` As a manager, provide strategic insights, performance summaries, and actionable recommendations. response should be pointwise in use html elements`;
                        break;
                    case 'Executive':
                        prompt += ` As an executive, focus on high-level strategic insights, KPIs, and business impact. response should be pointwise in use html elements`;
                        break;
                }
                const isChartRequest = detectChartRequest(query);

                if (isChartRequest) {
                    prompt = `You are ${selectedRole}, a data visualization expert using D3.js. Based on the QlikSense data provided, create a data structure suitable for rendering a D3.js chart.

                    IMPORTANT: Respond with a JSON object containing:
                    1. "message": A brief explanation of the chart.
                    2. "chartData": A data structure (JSON array) suitable for D3.js.  This should be an array of objects, where each object represents a data point.  Include the data itself, labels, and any other information needed to render the chart.
                    3. "chartType": The type of chart (bar, line, pie, scatter, column, etc.).  If the chart is 3D, specify that in the chartType.

                    For example, for a bar chart:

                    {
                        "message": "Here's a bar chart showing...",
                        "chartData": [
                            {"label": "Label1", "value": 10},
                            {"label": "Label2", "value": 20}
                        ],
                        "chartType": "bar"
                    }

                    For a 3D scatter plot:

                    {
                        "message": "Here's a 3D scatter plot showing...",
                        "chartData": [
                            {"x": 1, "y": 2, "z": 3, "label": "Point1"},
                            {"x": 4, "y": 5, "z": 6, "label": "Point2"}
                        ],
                        "chartType": "scatter3d"
                    }

                    Do NOT include any D3.js code in your response.  Only provide the data structure.
                    `;
                }

                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${decryptedKey}`
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: [{
                                role: "user",
                                content: `${prompt} data:${sursa} query:${query}`
                            }],
                            temperature: temp,
                            max_tokens: 2000,
                            response_format: isChartRequest ? {
                                type: "json_object"
                            } : undefined
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    const aiResponse = data.choices[0].message.content;

                    hideTypingIndicator();

                    if (isChartRequest) {
                        try {
                            const chartResponse = JSON.parse(aiResponse);
                            console.log('AI Response:', chartResponse);
                            if (lastContainerId) {
                                console.log('lastContainerId:', lastContainerId);
                                generateChart(lastContainerId, chartResponse.chartData, chartResponse.chartType);
                            } else {
                                addMessage('bot', chartResponse.message || 'Here\'s your chart:', chartResponse.chartData, chartResponse.chartType);
                            }
                        } catch (parseError) {
                            console.error('Error parsing chart response:', parseError);
                            addMessage('bot', 'I encountered an error generating the chart. Here\'s the analysis instead: ' + aiResponse);
                        }
                    } else {
                        addMessage('bot', aiResponse);
                    }

                } catch (error) {
                    console.error('Error calling AI API:', error);
                    hideTypingIndicator();
                    addMessage('bot', 'I apologize, but I encountered an error processing your request. Please try again.');
                }
            }

            function addMessage(sender, message, chartData = null, chartType = null) {
                const $messages = $element.find('.chat-messages');
                const timestamp = new Date().toLocaleTimeString();
                const messageId = 'msg_' + Date.now();

                let messageClass = sender === 'user' ? 'user-message' : 'bot-message';
                let icon = sender === 'user' ? '\ud83d\udc64' : '\ud83e\udd16';
                let name = sender === 'user' ? currentUser : 'AI Assistant';

                if (sender === 'system') {
                    messageClass = 'system-message';
                    icon = '\u2699\ufe0f';
                    name = 'System';
                }

                let messageHtml = `
                    <div class="message ${messageClass}" id="${messageId}">
                        <div class="message-content">
                            <div class="message-header">
                                <span class="${sender}-icon">${icon}</span>
                                <span class="${sender}-name">${name}</span>
                                <span class="timestamp">${timestamp}</span>
                            </div>
                            <div class="message-text">${message}</div>
                            ${chartData ? `<div class="chart-container" id="chart_${messageId}"></div>` : ''}
                            <div class="hear-responce ${sender}">
                                <button class="speak-button" onclick="speakText('${message.replace(/'/g, "\\'")}')">
                                    <i class="fas fa-volume-up"></i>
                                </button>
                                <button class="copy-button" onclick="copyToClipboard('${message.replace(/'/g, "\\'")}')">
                                    <i class="fas fa-copy"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `;

                $messages.append(messageHtml);
                $messages.scrollTop($messages[0].scrollHeight);

                if (chartData) {
                    lastContainerId = `chart_${messageId}`;
                    $timeout(() => {
                        generateChart(lastContainerId, chartData, chartType);
                    }, 300);
                }

                chatHistory.push({
                    sender: sender,
                    message: message,
                    timestamp: timestamp,
                    chartData: chartData
                });
            }

            function generateChart(containerId, chartData, chartType) {
                const container = document.getElementById(containerId);
                if (!container) {
                    console.error('Chart container not found:', containerId);
                    return;
                }

                container.innerHTML = ''; // Clear previous content

                const width = container.offsetWidth;
                const height = container.offsetHeight;

                // Create SVG element
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                if (chartType === 'bar') {
                    // Example D3 bar chart
                    const xScale = d3.scaleBand()
                        .domain(chartData.map(d => d.label))
                        .range([0, width])
                        .padding(0.1);

                    const yScale = d3.scaleLinear()
                        .domain([0, d3.max(chartData, d => d.value)])
                        .range([height, 0]);

                    svg.selectAll('.bar')
                        .data(chartData)
                        .enter().append('rect')
                        .attr('class', 'bar')
                        .attr('x', d => xScale(d.label))
                        .attr('y', d => yScale(d.value))
                        .attr('width', xScale.bandwidth())
                        .attr('height', d => height - yScale(d.value))
                        .attr('fill', 'steelblue');

                    // Add axes (simplified)
                    svg.append('g')
                        .attr('transform', `translate(0, ${height})`)
                        .call(d3.axisBottom(xScale));

                    svg.append('g')
                        .call(d3.axisLeft(yScale));
                } else if (chartType === 'scatter3d') {
                    // Example D3 3D scatter plot (using d3-3d)
                    const origin = [width / 2, height / 2];
                    const scale = 20;
                    let circles = [];

                    const x3d = d33d.x3d()
                        .scale(scale)
                        .origin(origin)
                        .rotateY(0)
                        .rotateX(0);

                    function processData(data) {
                        circles = svg.selectAll('circle')
                            .data(data)
                            .enter()
                            .append('circle')
                            .attr('class', '_3d')
                            .attr('cx', posPointX)
                            .attr('cy', posPointY)
                            .attr('r', 5)
                            .attr('fill', 'red')
                            .attr('stroke', '#fff');
                    }

                    function posPointX(d) {
                        return x3d.project(d).x;
                    }

                    function posPointY(d) {
                        return x3d.project(d).y;
                    }

                    function rotateX(degrees) {
                        x3d.rotateX(degrees);
                        svg.selectAll('._3d')
                            .attr('cx', posPointX)
                            .attr('cy', posPointY);
                    }

                    function rotateY(degrees) {
                        x3d.rotateY(degrees);
                        svg.selectAll('._3d')
                            .attr('cx', posPointX)
                            .attr('cy', posPointY);
                    }

                    processData(chartData);

                    // Example rotation (you'll need to add UI controls for this)
                    d3.interval(() => {
                        rotateY(1);
                        rotateX(0.5);
                    }, 50);

                } else {
                    console.warn('Unsupported chart type:', chartType);
                    svg.append('text')
                        .attr('x', width / 2)
                        .attr('y', height / 2)
                        .attr('text-anchor', 'middle')
                        .text('Unsupported chart type: ' + chartType);
                }
            }

            function showTypingIndicator() {
                const $messages = $element.find('.chat-messages');
                const typingHtml = `
                    <div class="message typing-indicator">
                        <div class="message-content">
                            <div class="typing-animation">
                                <span></span>
                                <span></span>
                                <span></span>
                            </div>
                        </div>
                    </div>
                `;
                $messages.append(typingHtml);
                $messages.scrollTop($messages[0].scrollHeight);
            }

            function hideTypingIndicator() {
                $element.find('.typing-indicator').remove();
            }

            function toggleVoiceInput() {
                if (!recognition) {
                    alert('Voice recognition is not supported in your browser.');
                    return;
                }

                const $voiceBtn = $element.find('.voice-button');

                if (isListening) {
                    recognition.stop();
                    isListening = false;
                    $voiceBtn.removeClass('listening');
                } else {
                    recognition.start();
                    isListening = true;
                    $voiceBtn.addClass('listening');
                }

                recognition.onresult = function(event) {
                    const transcript = event.results[0][0].transcript;
                    $element.find('.chat-input').val(transcript);
                    isListening = false;
                    $voiceBtn.removeClass('listening');
                };

                recognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    isListening = false;
                    $voiceBtn.removeClass('listening');
                };
            }

            function downloadChatHistory() {
                const dataStr = JSON.stringify(chatHistory, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);

                const exportFileDefaultName = `chat_history_${new Date().toISOString().split('T')[0]}.json`;

                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
            }

            $scope.$on('$destroy', function() {
                Object.values(chartInstances).forEach(chart => {
                    // D3 charts don't need explicit disposal in this simple example,
                    // but you might need to clean up event listeners or other resources
                    // in more complex scenarios.
                });
                chartInstances = {};
            });
        }]
    };
});
